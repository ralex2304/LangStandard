# Стандарт промежуточного представления программы компилятором

## Общее

Кодировка файла `cp1251`

## Команды
|Num| Name            |Type    | Description |
|---|-----------------|--------|-------------|
| 1 | CMD_SEPARATOR   | LIST   | Разделитель команд. Имитирует список. Левый потомок - команда, правого или нет, или такой же разделитель
| 2 | VAR_DEFINITION  | BINARY | определение переменной. Слева лист типа переменная, справа выражение
| 3 | CONST_VAR_DEF   | UNARY  | Опциональный родитель VAR_DEFINITION
| 4 | FUNC_DEFINITION | BINARY | Определение функции. Слева поддерево: (VAR_SEPARATOR (переменная) (поддерево аргументов (список VAR_SEPARATOR'ов))). Справа список команд через CMD_SEPARATOR
| 5 | ASSIGNMENT      | BINARY | Присваивание. Слева лист переменная, справа выражение
| 6 | ASSIGNMENT_ADD  | BINARY |
| 7 | ASSIGNMENT_SUB  | BINARY |
| 8 | ASSIGNMENT_MUL  | BINARY |
| 9 | ASSIGNMENT_DIV  | BINARY |
|10 | RETURN          | UNARY  | Возврат из функции. Слева ничего, справа выражение
|15 | VAR_SEPARATOR   | LIST   | Имитатор списка для аргументов функции и т.п.
|16 | FUNC_CALL       | BINARY | Вызов функции. Слева лист переменная, справа список выражений через VAR_SEPARATOR
|20 | MATH_ADD        | BINARY | Сложение
|21 | MATH_SUB        | BINARY | Вычитание
|22 | MATH_MUL        | BINARY | Умножение
|23 | MATH_DIV        | BINARY | Деление
|24 | MATH_SQRT       | UNARY  | Корень
|25 | MATH_SIN        | UNARY  | Синус
|26 | MATH_COS        | UNARY  | Косинус
|27 | MATH_NEGATIVE   | UNARY  | Унарный минус
|28 | MATH_DIFF       | BINARY | Оператор дифф. Слева выражение, справа лист-переменная с номером переменной, по которой дифф.
|30 | LOGIC_GREAT     | BINARY | >
|31 | LOGIC_LOWER     | BINARY | <
|32 | LOGIC_NOT_EQUAL | BINARY | !=
|33 | LOGIC_EQUAL     | BINARY | ==
|34 | LOGIC_GREAT_EQ  | BINARY | >=
|35 | LOGIC_LOWER_EQ  | BINARY | <=
|40 | PREFIX_ADD      | BINARY | ++x <br> 1) Слева обязательно переменная, справа, либо следующий препост-оператор, либо ничего, либо переменная (последние два варианта означают одно и то же). В таком списке операторов все переменные должны иметь один номер. Такое дублирование сделано для оптимального чтения на бекенде; <br> 2) Сначала только префиксные операторы, потом только постфиксные. То есть префиксный не может быть потомком постфиксного. <br><br> Аналогично для всех препост-операторов
|41 | PREFIX_SUB      | BINARY | --x
|42 | POSTFIX_ADD     | BINARY | x++
|43 | POSTFIX_SUB     | BINARY | x--
|50 | WHILE           | BINARY | while. Слева вычисляемое выражение, справа либо список команд, либо ELSE
|51 | DO_WHILE        | BINARY | do {} while (). Аналогично, ELSE нельзя
|53 | IF              | BINARY | Аналогично
|54 | DO_IF           | BINARY | do {} if () - не спрашивайте, можете забить
|56 | ELSE            | BINARY | Слева список команд, если выполняется основная ветвь, справа если else ветвь
|57 | BREAK           | LEAF   | break
|58 | CONTINUE        | LEAF   | continue
|70 | IN              | LEAF   | команда асма IN
|71 | OUT             | UNARY  | команда асма OUT. Слева ничего, справа выражение
|72 | SHOW            | LEAF   | команда асма SHOW
|73 | SET_FPS         | UNARY  | команда асма SET_FPS. Слева ничего, справа выражение

## Типы узлов

- `1` - оператор. Значение - номер оператора
- `2` - число. Значение - число
- `3` - переменная. Значение - номер переменной

## Формат

Инфиксная запись

Каждый узел характеризуется дебаг инфой, типом, значением и потомками. Если нет потомка, что `(nil)`

```({<путь до исходника>, <номер строки>, <номер символа с начала строки>, <номер первого символа строки с начала файла>}, <тип>, <значение>, <левый потомок> <правый потомок>)```

E.g.
```({"main.code", 1, 2, 3}, 0, 0, (nil) (nil))```


## Файл

Сначала идёт дерево. Затем `\n` и список имён переменных (каждое имя на новой строке). Нумерация с 0, соответсвует порядку

E.g.
```
({"main.code", 1, 2, 3}, 0, 0, (nil) (nil))
x
y
z

```
